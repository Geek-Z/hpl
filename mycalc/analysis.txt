1. 定义计算器接受到字符串当中的单词的分类

(1) 运算符: +, -, *, /
(2) 整数: 123
(3) 实数: 123.456
(4) 换行符: 当检测到的换行符的时候需要得到输出结果

2. flex 根据一个后缀为 .l 的文件生成词法分析器的c语言代码
3. yacc 根据一个后缀为 .y 的文件生成语法分析器的c语言代码

==================== flex 语法 ==============================

1. %{ %} 之间的部分为定义区块儿 : 定义初始状态 和 为表达式命令, 其中的代码会进行原样的输出
2. %% %% 之间是规则区块儿: 使用正则表达式对应一段C语言代码, 对于只有种别码的终结符直接返回其种别码, 需要其原始串的可以通过全局变量获得, 需要值的则自行解析并保存到全局变量当中去。 这里的C代码被称为的动作(Action)
	(1) 概念: 特征符, 原始字符串, 记号的值。

    %% %% 之后的代码则为用户代码区块, 用户区中可以编写任意的C语言代码。
3. y.tab.h 是yacc/bison 生成的头文件: 其中包含特征符的宏定义

4. 全局变量:
        (1) yytext 是正则表达式匹配到的原始字符, 需要使用到的值的时候使用sscanf进行解析即可
        (2) yylval 是定义在 yacc 生成的头文件当中的一个联合体

===================== yacc 语法 =============================
1. %{ %} 之间为定义区块儿, 和 flex 是一样的。
2. #define YYDEBUG 设置为非0值, 开启debug模式, 能看到程序运行当中的语法分析状态。
3. %union 定义了终结符的值的所有类型, 其会根据这个配置生成一个 yylval 的union。
4. %% %% 之间定义文法。
5. %token 定义终结符, %type 定义非终结符
    
   %token ADD SUB MUL DIV CR  表明定义了5个终结符, 且其没有值的类型
   %token <double_value> DOUBLE_LITERAL 表明定义了一个值的类型为 union 成员 double_value 相同类型的一个终结符。
   %type <double_value> expression ..... 则定义了一些非终结符, 并指明其值的类型。
   

==================== yacc 的移进归约 ========================

1. yacc生成的解析器当中会包含一个栈, 当移动进入栈当中的元素匹配到产生式的时候会发生归约。
2. 归约: 会看一下下一个待移进的终结符, 决定当前能归约到何种程度, 比如:
     1 + 2 * 3:
     
     1 进入到栈的时候, 根据后面能看到的 + 号, 最终只会被归约成 expression, 其归约过程如下
     1 --> DOUBLE_LITERAL --> primary_expression --> term --> expression 可见, 其既没有中途停下, 也没有继续向上归约成line。

===================== $$, $1, $2, $3 的含义 =================

term MUL primary_expression
{
    $$ = $1 * $s3;
}

$$ 表示归约后的符号的值
$1 表示term符号的值
$3 表示 primary_expression的值
由于 MUL 是没有值的, 因此当使用 $2 的时候必定会报错。

如果没有书写动作, 比如

primary_expression
    : DOUBLE_LITERAL

会自动添加一个动作
{
$$ = $1;
}

$$ 和 $1 代表符号的类型必须保持一致才行。
来表示当前符号的值, 当然前提是当前的非终结符是有值的符号, 终结符也是有值的符号, 否则会发生错误。

===================== 生成执行文件 ============================

1. 先生成语法分析器的C语言文件
bison --yacc -dv mycalc.y

2. 再生成词法分析器的C语言文件
flex mycalc.l

3. 再编译成可执行的文件
cc -o mycalc y.tab.c lex.yy.c

=================== 冲突 ======================================
1. shift/reduce 冲突, bison 的解决方案是归约优先于移进
2. reduce/reduce 冲突, bison 的解决方案使用最前面的那个规则(产生式).


bison 产生的解析器的shift/reduce过程可以用栈的方式来演示, 但是具体的编程实现不会用这么耗时的操作来实现, 而是使用解析对照表的, 当shift进入什么符号, 就会跳转到什么状态当中去, 进而节省了语法分析的时间。



